# Лабораторная работа №3: Сингулярное разложение и сжатие изображений в формате BMP 

## Доступные реализации нахождения сингулярного разложения

- `numpy` - использует реализацию из numpy
- `naive` - использует QR-алгоритм
- `advance` - использует [блочный степенной метод](https://www.degruyter.com/document/doi/10.1515/jisys-2018-0034/html)

## Описание структуры файла сжатого изображения

Сначала идут три параметра width, height, k типа uint32 - параметры, задающие ширину, высоту изображения и ранг сингулярного разложения. 

Далее задаются сингулярные разложения цветовых каналов изображения (красный, зелёный и синий соответственно) в виде одномерных массивов: 

U([float32] * (width * k)), Sigma ([float32] * k), Vt ([float32] * (k * height)) 


## Результаты 

Все три метода сжимают примерно одинаково, так что визуально по изображению нельзя никак определить, с помощью какого методо оно было получено. В этом можно убедиться, сделав компрессию с очень большим коэффициентом сжатия, например N = 40:

| numpy                                           | naive                                           | advanced                                             |
|---------------------------------------------------|---------------------------------------------------|----------------------------------------------------|
| ![](compressed/nature_numpy_40.bmp) | ![](compressed/nature_naive_40.bmp) | ![](compressed/nature_advanced_40.bmp) |


Что в принципе логично, так как при упорядочивании сингулярных значений, SVD-разложение можно считать единственным.

Видно, что для фактора 40 изображения уже получаются совершенно размытыми, лишь удалено напоминающими исходную картинку. Однако для небольших коэффициентов сжатие работает очень даже неплохо:

| numpy (N = 1)                                          | naive (N = 2)                                          | advanced (N = 4)                                            |
|---------------------------------------------------|---------------------------------------------------|----------------------------------------------------|
| ![](compressed/nature_numpy_1.bmp) | ![](compressed/nature_naive_2.bmp) | ![](compressed/nature_advanced_4.bmp) |

По времени работы самым эффективным оказался стандартный алгоритм, реализованный в модуле numpy. Далее идёт naive алгоритм. Ну и самым долгим оказался Advanced, причем этот алгоритм он волатилен по времени, так как у него есть настраиваемый параметр толерантности, которым можно регулировать точность приближаемого исходную матрицу сингулярного разложения и от которого соответстенно зависит время исполнения.

Однако несмотря на увеличение точности приближения исходной матрицы, визуально не получилось добиться никаких явных улучшений качества изображения, поэтому исходного eps=0.1 и как следствие сильного увеличения времени работы можно для фактора сжатия N = 8 добиться лучшего качества сжатия:

| advanced (N = 2, EPS = 1e-8)                                       | advanced (N = 2, EPS = 1e-6)                                       | advanced (N = 2, EPS = 1e-1)                                          |
|---------------------------------------------------|---------------------------------------------------|----------------------------------------------------|
| ![](compressed\sample_advanced_1e_8.bmp) | ![](compressed\sample_advanced_1e_6.bmp) | ![](compressed\sample_advanced_1e_1.bmp) |


| advanced (N = 2, EPS = 10)                                       | advanced (N = 2, EPS = 100)                                       | advanced (N = 2, EPS = 1000)                                          |
|---------------------------------------------------|---------------------------------------------------|----------------------------------------------------|
| ![](compressed\sample_advanced_eps=10.bmp) | ![](compressed\sample_advanced_eps=100.bmp) | ![](compressed\sample_advanced_eps=1000.bmp) |

Но в то же время, можно заметить, что изображения блочным методом приближаются достаточно быстро, так что буквально нескольких итераций уже хватает для получения удовлетворительного качества приближения:

| advanced (N = 2, 1 iteration)                                       | advanced (N = 2, 3 iterations)                                       | advanced (N = 2, 5 iterations)                                          | advanced (N = 2, 10 iterations)                                       | 
|---------------------------------------------------|---------------------------------------------------|----------------------------------------------------|---------------------------------------------------|
| ![](compressed\sample_advanced_1_it.bmp) | ![](compressed\sample_advanced_3_it.bmp) | ![](compressed\sample_advanced_5_it.bmp) | ![](compressed\sample_advanced_10_it.bmp) |


| advanced (N = 8, 2 iterations)                                       | advanced (N = 8, 3 iterations)                                       | advanced (N = 8, 7 iterations)                                          | advanced (N = 8, 15 iterations)                                       | 
|---------------------------------------------------|---------------------------------------------------|----------------------------------------------------|---------------------------------------------------|
| ![](compressed\nature_2_it.bmp) | ![](compressed\nature_3_it.bmp) | ![](compressed\nature_7_it.bmp) | ![](compressed\nature_15_it.bmp) |